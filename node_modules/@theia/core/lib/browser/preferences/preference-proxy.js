"use strict";
/********************************************************************************
 * Copyright (C) 2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-any
var common_1 = require("../../common");
var Ajv = require("ajv");
function createPreferenceProxy(preferences, schema) {
    var configuration = createConfiguration(schema);
    var ajv = new Ajv();
    var validateFunction = ajv.compile(schema);
    var validate = function (name, value) {
        var _a;
        return validateFunction((_a = {}, _a[name] = value, _a));
    };
    var toDispose = new common_1.DisposableCollection();
    var onPreferenceChangedEmitter = new common_1.Emitter();
    toDispose.push(onPreferenceChangedEmitter);
    toDispose.push(preferences.onPreferenceChanged(function (e) {
        if (e.preferenceName in configuration) {
            if (e.newValue !== undefined) {
                if (validate(e.preferenceName, e.newValue)) {
                    onPreferenceChangedEmitter.fire(e);
                }
                else {
                    onPreferenceChangedEmitter.fire({
                        preferenceName: e.preferenceName,
                        newValue: configuration[e.preferenceName]
                    });
                }
            }
            else {
                onPreferenceChangedEmitter.fire({
                    preferenceName: e.preferenceName,
                    newValue: configuration[e.preferenceName],
                    oldValue: e.oldValue
                });
            }
        }
    }));
    var unsupportedOperation = function (_, property) {
        throw new Error('Unsupported operation');
    };
    return new Proxy(configuration, {
        get: function (_, property) {
            if (property in configuration) {
                var preference = preferences.get(property, configuration[property]);
                if (validate(property, preference)) {
                    return preference;
                }
                else {
                    return configuration[property];
                }
            }
            if (property === 'onPreferenceChanged') {
                return onPreferenceChangedEmitter.event;
            }
            if (property === 'dispose') {
                return function () { return toDispose.dispose(); };
            }
            if (property === 'ready') {
                return preferences.ready;
            }
            throw new Error('unexpected property: ' + property);
        },
        set: unsupportedOperation,
        deleteProperty: unsupportedOperation,
        defineProperty: unsupportedOperation
    });
}
exports.createPreferenceProxy = createPreferenceProxy;
function createConfiguration(schema) {
    var configuration = {};
    // tslint:disable-next-line:forin
    for (var property in schema.properties) {
        configuration[property] = common_1.deepFreeze(schema.properties[property].default);
    }
    return configuration;
}
//# sourceMappingURL=preference-proxy.js.map