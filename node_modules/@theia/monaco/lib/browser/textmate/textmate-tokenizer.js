"use strict";
/********************************************************************************
 * Copyright (C) 2018 Ericsson and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var monaco_textmate_1 = require("monaco-textmate");
var State = /** @class */ (function () {
    function State(ruleStack) {
        this.ruleStack = ruleStack;
    }
    State.prototype.clone = function () {
        return new State(this.ruleStack);
    };
    State.prototype.equals = function (other) {
        return other &&
            (other instanceof State) &&
            (other === this || other.ruleStack === this.ruleStack);
    };
    return State;
}());
exports.State = State;
function createTextmateTokenizer(grammar) {
    return {
        getInitialState: function () { return new State(monaco_textmate_1.INITIAL); },
        tokenize: function (line, state) {
            var result = grammar.tokenizeLine(line, state.ruleStack);
            var tokenTheme = monaco.services.StaticServices.standaloneThemeService.get().getTheme().tokenTheme;
            var defaultResult = tokenTheme.match(undefined, 'should.return.default');
            var defaultForeground = monaco.modes.TokenMetadata.getForeground(defaultResult);
            return {
                endState: new State(result.ruleStack),
                tokens: result.tokens.map(function (token) {
                    var scopes = token.scopes.slice(0);
                    // TODO monaco doesn't allow to pass multiple scopes and have their styles merged yet. See https://github.com/Microsoft/monaco-editor/issues/929
                    // As a workaround we go through the scopes backwards and pick the first for which the tokenTheme has a special foreground color.
                    for (var i = scopes.length - 1; i >= 0; i--) {
                        var scope = scopes[i];
                        var match = tokenTheme.match(undefined, scope);
                        var foregroundColor = monaco.modes.TokenMetadata.getForeground(match);
                        if (defaultForeground !== foregroundColor) {
                            return __assign({}, token, { scopes: scope });
                        }
                    }
                    return __assign({}, token, { scopes: scopes[0] });
                }),
            };
        }
    };
}
exports.createTextmateTokenizer = createTextmateTokenizer;
//# sourceMappingURL=textmate-tokenizer.js.map